
# 处理不同端消息传递

## 原则:
*****
在浏览器JS端和C++端传送消息，可用于webworker之间，也可以在CEF框架的render process和v8context之间传送消息。

由于浏览器端JS代码和Native的C++代码会存在版本问题，所以MSG本身具有版本除错能力，版本不一致的时候，程序会直接crash（认为是编译导致的错误）。
*****

## 设计原理:
****
message为了达到快速系列化的效果，存储本身基于二进制结构`void*`或者`ArrayBuffer`。

所有的结构本身不包含自己的类型，可包含自身的children的类型。只有在children是复合类型的时候，才会包含children的类型。

message为了能正确的传递自己的类型，在message上第一个字段标示自己的类型。

结构体本身实现了基本类型和递归类型，递归类型由：Array，Map，Set来实现

消息分为主结构和次结构，主结构中存在消息类型，而辅助结构中不存在。
辅助结构的类型由上一级结构中决定，辅助结构的类型可支持 **或** 的聚合类型。

辅助结构分为两种，一种是确定`Size`的，一种是不确定`Size`的，确定`Size`的直接在原地实例化，合并到上一层结构中。不确定`Size`的，在上一层结构里使用引用的方式存放。引用位64位结构，32位`offset` + 32位的`type`。

对于**或**结构的成员，固定使用引用结构（他们的`Size`）大部分不一样。

`undefine`类型，在符合类型中，`offset`为`-1`。
****

## 传输结构
在CEF和V8Context通信中，所有的`buffer`都来自于c++端，c++里使用消息内存池进行缓存。不涉及到内存的传递。

数据读取是非常快速的，在程序设计上不要copy里面的数据结构，如果有更改需要，可使用结构引用`message`的方式。
